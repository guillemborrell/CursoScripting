\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{mathptmx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{listings}

\lstset{language=Python,
  backgroundcolor=\color{black!20},
  numbers=left,
  extendedchars=true,
  inputencoding=utf8,
  basicstyle=\small\ttfamily,
  numberstyle=\tiny,
  keywordstyle=\color{blue},
  showstringspaces=false,
  showspaces=false}


\renewcommand\shorthandsspanish{}
\noextrasspanish

\author{Guillem Borrell Nogueras}
\title{Python como entorno de desarrollo científico.\\ Primera sesión}


\begin{document}

\section{Introducción}
Existe cierta confusión con los conceptos de lenguaje y
herramienta. Mientras una herramienta nace como respuesta a una
necesidad funcional los lenguajes sirven para dar sentido a la
realidad; se encuentran en planos completamente distintos. Los
lenguajes de programación tienen más en común con las lenguas o el
lenguaje matemático que con un mecanismo o un motor. Sin embargo uno
puede ahogarse en libros donde se analiza sistemáticamente un lenguaje
de programación como si de una herramienta se tratara.

Los parámetros para juzgar un lenguaje son ajenos a un ingeniero o un
matemático y más cercanos a un filósofo: aprendizaje, incertidumbre,
consistencia o formalismo. La programación es la creación de
literatura con un lenguaje específico y tiene ingredientes como la
sintaxis, el léxico... ¡Incluso faltas de ortografía! Un ingeniero
tiende a valorar según parámetros como la eficiencia, la simplicidad o
la rapidez.  Pocas veces constatamos el error que estos conceptos no
pueden aplicarse a un lenguaje porque son propios de los mecanismos.
Es algo bastante común: cuando sólo tienes un martillo todo te parece
un clavo.

Los lenguajes de programación evolucionan como las lenguas naturales.
Nacen a partir de lenguas primitivas y siguen uno de los dos caminos
posibles: la evolución o la muerte. Existen en ambos casos lenguas
muertas.  Podría compararse COBOL con el latín, a pocos se les
ocurriría aprenderlos hoy en día sin embargo los programas que
controlan las transacciones bancarias se escriben en COBOL al igual
que en el Vaticano se siguen analizando textos en latín.

Los lenguajes sirven para comunicar significado.  Utilizar el
castellano para una crónica futbolística es equivalente a formular un
teorema mediante un lenguaje matemático. Los lenguajes de programación
sirven para comunicar algoritmos a ordenadores. Aquí aparece otro
concepto crucial: comunicación.  Es una acción que requiere un
interlocutor y en la programación siempre es el mismo: un
ordenador. 

La comunicación con los ordenadores ha evolucionado rápidamente desde
la construcción del primer ordenador programable. Una anécdota
posiblemente apócrifa cuenta que Seymour
Cray\footnote{\url{http://en.wikipedia.org/wiki/Seymour_Cray}} era capaz
de arrancar el sistema operativo de un CDC7600 manipulando la memoria
de este ordenador primitivo a mano. Ahora los lenguajes de
programación son tan simples que hasta un niño de ocho años es capaz
de aprenderlos\footnote{Un texto clásico sobre la evolución de los
  lenguajes de programación es \emph{Real men don't use
    Pascal}: \url{http://www.pbm.com/~lindahl/real.programmers.html}}. ¿Quién
se esforzaría hoy en depurar un programa a partir del volcado de
memoria? Hablarle a los ordenadores es más sencillo porque se han
vuelto más listos, han evolucionado.

Python es fruto de esta evolución.  Es un lenguaje de programación de
quinta o sexta generación nacido cuando los ordenadores eran ya tan
potentes como para no tener que estar continuamente pensando en la
memoria y la velocidad de ejecución.  Es uno de los primeros lenguajes
de programación en los que su propia naturaleza no se ha visto
coartada por las limitaciones del ordenador. Es, en consecuencia, uno
de los lenguajes más humanos con los que se puede programar. Hoy pocos
discuten que una herramienta más cercana al programador ayuda a
implementar algoritmos más complejos en menos tiempo y a cometer menos
errores. Esto es fundamental para que quienes no disponen de una
formación específica en la programación, como científicos e
ingenieros, escriban programas sin tener que aprender más allá de lo
fundamental.

Los lenguajes de programación de alto nivel deben traducirse mediante
compilador o un intérprete. Este es el punto donde se crea la
confusión: el compilador o el intérprete sí son herramientas desde el
punto de vista técnico. La naturaleza de un lenguaje de programación
influye significativamente en el diseño y posibilidades del compilador
o del intérprete.  Por ejemplo, en los lenguajes dinámicos como Python
el tipo de las variables se conoce en tiempo de ejecución.  Esto añade
ciertas posibilidades al lenguaje como el hecho de no tener que
declarar las variables.  Muchos de estos lenguajes no pueden ser
compilados lo que ya impone que la comunicación nunca podrá efectuarse
con un compilador sino que tendrá que ser con un intérprete.

Un ingeniero no tiene la formación necesaria para analizar un lenguaje
pero sí puede entrar en la discusión sobre qué maquinaria, ya sea
interprete o compilador, es más adecuada en cada caso.  Es en este
punto donde el lenguaje pasa a un segundo plano, por ejemplo: utilizar
las posibilidades de optimización de un compilador de C, aparcando por
ello Python, a pesar de sus peores características como lenguaje. Es
la suma todas las herramientas necesarias para resultar productivo lo
que influye en el proceso de decisión.

\emph{Este artículo pretende analizar cada una de las ventajas de utilizar
Python en un entorno científico y técnico, describir los posibles
inconvenientes y proponer soluciones para minimizar su efecto}.

Programar en Python es más efectivo porque es más potente sin ser más
complejo.  Las razones por las que no se ha impuesto aún en un entorno
científico y técnico son las siguientes:

\begin{itemize}
\item El desconocimiento.
\item Que el intérprete no se comporte de la manera adecuada.
\end{itemize}

Si ya estamos convencidos de la superioridad como lenguaje de Python
¿Es realmente necesario desperdiciar sus bondades como lenguaje por
culpa de las características del intérprete?  El objetivo de este
ensayo es \emph{demostrar que Python dispone en la actualidad de una
  colección de herramientas suficientes como para minimizar la mayoría
  de los inconvenientes que podrían descartar su uso}.

\subsection{Un enfoque distinto para cada problema}

Las aplicaciones de simulación pueden dividirse en dos grandes grupos
según sus necesidades computacionales.

\begin{itemize}
\item Los pequeños programas de entre una decena y el millar de líneas
  de código con la misión de realizar un cálculo relativamente simple
  llamados guiones o \emph{scripts}.
\item Las grandes simulaciones de computación de alto rendimiento con
  tiempos de ejecución largos en superordenadores y ciclos de vida de
  años o décadas.
\end{itemize}

Los \emph{scripts} suelen implementarse en lenguajes interpretados
especializados en matemáticas e ingeniería, la mayoría de ellos
propietarios, que permiten un acceso sencillo y directo a una enorme
biblioteca de funciones especializadas\footnote{Los lenguajes de
  \emph{nicho} o diseñados específicamente para un sector reciben el
  nombre de \emph{Domain Specific Languages}, a partir de ahora DSL}.
En este ámbito Python compite directamente con Matlab, Mathematica,
Maple, IDL... En estos casos Python es ya una alternativa a este
software ya que ofrece funcionalidades muy parecidas a coste
cero. Esto significa que Python debe disponer de una colección de
bibliotecas considerable y comparable con los productos comerciales
actuales. Las primeras secciones de este artículo se dedicarán a
listar de un modo poco detallado todas las bibliotecas y aplicaciones
que han sido escritas en Python o utilizan el intérprete de Python de
utilidad en Matemáticas, Física o Ingeniería.

En el otro extremo, tradicionalmente se ha argumentado que debido a
que los programas más exigentes desde un punto de vista computacional
deben programarse en el lenguaje que asegure una máxima velocidad en
la ejecución prescindiendo de ciertas propiedades deseables. Si bien
existen unos pocos casos patológicos en los que la velocidad es la
única variable a tener en cuenta\footnote{Algunos códigos de Mecánica
  de Fluidos Computacional tienen tiempos de ejecución de meses o
  incluso años y ciclos de desarrollo de entre dos y cuatro años.  Es
  comprensible que en estos casos no se tengan en cuenta muchas de las
  técnicas que se proponen en este artículo.}, en la mayoría la parte
del código que explota al máximo hardware se reduce a unas pocas
líneas. Este artículo dedicará sus últimas scciones a comentar las
distintas técnicas de optimización de código y qué posibilidades
ofrece Python para ello.


\section{Scripting en Python}

Python fue diseñado como un lenguaje de scripting para uso
general. El principal criterio de diseño se resume en una frase:
\emph{en Python sólo debe existir una manera elegante y lógica de
  hacer cualquier cosa}. Esta condición de diseño tan poco precisa se
complementa con lo siguiente:

\begin{itemize}
\item Ser lo suficientemente simple como para que pueda recordarse
  fácilmente.
\item Soportar todos los paradigmas modernos de programación.
\item Ofrecer una librería estándar amplia que responda a la mayoría
  de las necesidades.
\item Forzar una sintaxis clara y un código leíble y fácilmente
  modificable.
\end{itemize}

La programación en Python se ha convertido paulatinamente en la
expresión del minimalismo en la programación y queda reflejada en el
código \emph{zen} de Python. Es una buena oportunidad para ejecutar el
primer comando dentro de una consola de python\footnote{Para ejecutar
  este comando debe disponerse de un intérprete de Python. Si no está
  instalado en el sistema puede seguirse el tutorial del apéndice
  \ref{sec:instalar}.}.

\begin{lstlisting}
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
\end{lstlisting}

Estas características han convertido Python en el entorno de
desarrollo ideal para quienes no tienen conocimientos específicos
sobre entornos de desarrollo pero sí saben programar como suele ser
habitual entre científicos e ingenieros. Su crecimiento en el ámbito
de la enseñanza es lento pero constante y viene confirmado por la
progresiva aparición de proyectos científicos que utilizan Python como
lenguaje de programación.

Aunque es muy adecuado para iniciarse en la programación aún no se ha
popularizado lo suficiente como para que se enseñe en las
universidades.  Consecuencia directa de ello es que la gran mayoría de
quienes se interesan por Python lo hacen ya habiendo aprendido otros
lenguajes.  Si se posee cierta experiencia programando Python es muy
fácil de aprender, la documentación dispone de un tutorial que puede
completarse en un par de horas y asimilarse en unos pocos
días. Dispone de una consola interactiva completamente funcional y es
de gran ayuda para experimentar o manipular directamente resultados.

En UNIX la manera más sencilla de iniciar una consola es mediante el
terminal, simplemente escribiendo \emph{python} en él.

\begin{lstlisting}
$ python
Python 2.5.2 (r252:60911, Jun 28 2008, 04:30:43)
[GCC 4.3.1] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>                                                                    
\end{lstlisting}

En Windows el instalador oficial proporciona también una que puede
arrancarse a partir de la entrada correspondiente en el menú de
inicio.

Cualquier instrucción de código Python es entendida del mismo modo por
el intérprete y por la consola. Esta es, por ejemplo, la manera más
sencilla de sacar por pantalla la serie de Fibonacci:

\begin{lstlisting}
>>> (a,b)=(0,1)
>>> while b < 10:
...     print b
...     (a,b)=(b,a+b)
...
1
1
2
3
5
8
\end{lstlisting}

Los programadores con cierta experiencia habrán distinguido las
siguientes particularidades:

\begin{itemize}
\item El tipo definido entre paréntesis es un tuple y es una
  generalización de las variables que funciona también en la
  asignación.
\item La definición de los bloques de ejecución, en este caso un bucle
  lógico, se definen por el sangrado del propio bloque.  Esta
  característica crea tantos adeptos como detractores.
\item Representar en pantalla es tan sencillo como escribir la
  variable tras el comando print.
\end{itemize}

Tan sencillo como este juego matemático es crear una ventana gráfica
sobre la que empezar un interfaz de usuario

\begin{lstlisting}
>>> from Tkinter import *
>>> t=Tk()
\end{lstlisting}

Acto seguido aparece la ventana representada en la figura \ref{fig:tk}

\begin{figure}[h!]
\label{fig:tk}
  \centering
  \pgfimage[width=4cm]{files/tk.jpg}
  \caption{Ventana gracias al módulo Tkinter}
\end{figure}

También esta vez los programadores expertos habrán notado que el
mecanismo para cargar en el intérprete nuevas funciones son los
módulos y que a su vez cada módulo es un \emph{namespace}.

La última particularidad digna de mención antes de empezar con las
características del lenguaje es mencionar la ayuda interactiva.  Cada
función de la biblioteca estándar, que analizaremos a continuación,
está meticulosamente documentada para que cualquier sesión con el
interprete pueda ser además una visita a la documentación.  Por
ejemplo:

\begin{lstlisting}
>>> import cmath
>>> help(cmath.acos)
Help on built-in function acos in module cmath:

acos(...)
    acos(x)

    Return the arc cosine of x.
\end{lstlisting}

Puede apreciarse que los módulos no sólo definen un \emph{namespace}
sino que además cada módulo es un objeto.  A partir de la función
\emph{help} puede consultarse la documentación de cada función a
través del intérprete.

\emph{Recuerda que en los lenguajes interpretados no hay tipos derivados}
\subsection{El lenguaje de programación Python}

Esta es sólo una breve introducción de las sentencias y la sintaxis
del lenguaje Python.  Es una descripción deliberadamente incompleta de
modo que el tutorial oficial del lenguaje\cite{TUT} se convierte a
partir de ahora en una lectura obligada.

Para dar un poco más de profundidad a este análisis tan breve todos
los tipos y las sentencias se compararán con las del lenguaje de
\emph{scripting} por excelencia dentro del entorno científico y
técnico, Matlab.

\subsubsection{Operaciones aritméticas}

Python puede utilizarse como una calculadora algebraica para realizar
las operaciones aritméticas usuales:

\begin{lstlisting}
>>> 2+2 #Suma
4
>>> 2-1 #Resta
1
>>> 2*4.5 #Multiplicacion
9.0
>>> 2/4.5 #Division
0.44444444444444442
\end{lstlisting}

Las únicas diferencias entre Python y Matlab es que hasta la versión 3.x
la divisón entre dos enteros devuelve otro entero:

\begin{lstlisting}
>>> 5/3
1
\end{lstlisting}

Para conseguir en la versión 2.x el mismo comportamiento que en la 3.x
bastará con introducir los siguientes comandos en el intérprete o con
incluirlos en el código fuente.

\begin{lstlisting}
>>> from __future__ import division
>>> 5/3
1.6666666666666667
\end{lstlisting}

Y que el operador potencia obedece al doble asterisco como en Fortran
mientras que el símbolo de acento circunflejo se reserva para el
operador \emph{XOR} como en C.

\begin{lstlisting}
>>> 5**3
125
\end{lstlisting}

Al igual que en Matlab la representación por omisión de los números en
coma flotante es la de doble precisión, es decir, el \emph{double} de
C.

Las funciones matemáticas báscias se encuentran en el módulo
\emph{math} y el soporte para números complejos en \emph{cmath}.

\begin{lstlisting}
>>> import math as m
>>> import cmath as c
>>> a=3.0+4.0j
>>> a/complex(2,1.3)
(1.968365553602812+0.72056239015817214j)
>>> c.exp(_)
(5.3794960137747223+4.7235385533272529j)
>>> m.exp(abs(_))
1285.5809221999864
\end{lstlisting}


En esta pequeña sección se muestran varias características de Python.

\begin{itemize}
\item La función exponencial, \emph{exp}, se encuentra tanto en el
  módulo \emph{math} para números en coma flotante como en el
  \emph{cmath} de modo que si sólo se importa la función puede existir
  un conflicto de nombres.  La solución es importar cada módulo en un
  namespace distinto.
\item Se puede generar un número complejo tanto directamente con la
  constante reservada \emph{j} como mediante la función \emph{complex}.
\item El carácter \emph{\_} es también una constante reservada que
  almacena el resultado del comando anterior.
\end{itemize}

\subsection{Control de flujo}

La gran particularidad de Python para el control de flujo es esa
peculiar manera de diferenciar los bloques de ejecución.

\subsubsection{If}

\begin{lstlisting}
>>> x = int(raw_input("Por favor, introduzca un entero: "))
>>> if x < 0:
...      x = 0
...      print 'Era negativo y lo he cambiado a cero'
... elif x == 0:
...      print 'Cero'
... elif x == 1:
...      print 'Uno'
... else:
...      print 'Mas'
...
\end{lstlisting}

\subsubsection{for}

Python, como en algunos lenguajes interpretados, las iteraciones no
son específicamente un bucle sino que se trata de la secuenciación de
un iterador.

\begin{lstlisting}
>>> a = ['gato', 'ventana', 'defenestrar']
>>> for x in a:
...     print x, len(x)
... 
gato 4
ventana 7
defenestrar 11
>>> for x in a: # Haced esto y morid
...    if len(x) > 6: a.insert(0, x)
\end{lstlisting}

Es importante no intentar modificar una lista mientras se está
iterando sobre ella, hay que crear una copia temporal gracias al
\emph{slicing}.

Disponemos también de las sentencias \texttt{break} y
\texttt{continue} para controlar el flujo de ejecución dentro del
bucle.

\subsubsection{La función \texttt{range}}

Esta función devuelve el iterador más sencillo posible, un contador

\begin{lstlisting}
>>> range(4)
[0, 1, 2, 3]
>>> range(3,12,3)
[3, 6, 9]
\end{lstlisting}

\subsubsection{Definición de funciones}

Ahora modificamos la función que crea la serie de fibonacci para que
devuelva una lista:

\begin{lstlisting}
def fib2(n): 
    """Devuelve una lista con la serie de Fibonacci hasta n."""
    result = []
    (a, b) = (0, 1)
    while b < n:
        result.append(b)
        (a, b) = (b, a+b)
    return result
\end{lstlisting}

Si una función debe devolver más de una variable debe utilizarse un
\emph{tuple}.  La palabra clave \emph{return} termina también con la
ejecución de la función así que es una estrategia más para el control
de flujo de ejecución.

\subsubsection{Funciones lambda}


Especialmente útiles en el caso que uno necesite devolver una función
como argumento de un método.  Python también soporta algunas
utilidades de la programación funcional como los decoradores.
\begin{lstlisting}
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
\end{lstlisting}

\subsection{Tipos}

Como todos los lenguajes modernos orientados a objetos como los tipos
\emph{estándares} a parte de disponen de una gran funcionalidad. El tipo
\emph{lista}, por ejmplo, proporciona métodos para realizar casi
cualquier operación que se nos pueda ocurrir con una lista.  Python
dispone de los siguientes:

\begin{itemize}
\item Enteros
\item Números en coma flotante
\item Números complejos
\item Cadenas de texto
\item Listas
\item Tuples
\item Conjuntos
\item Diccionarios
\end{itemize}

Cada uno de ellos viene definido por una clase propia dentro del
lenguaje con sus método asignados.  A continuación se presenta una
lista de todos los métodos disponibles dentro de la clase
\emph{lista}:

\begin{lstlisting}
a.__add__           a.__iadd__          a.__rmul__
a.__class__         a.__imul__          a.__setattr__
a.__contains__      a.__init__          a.__setitem__
a.__delattr__       a.__iter__          a.__setslice__
a.__delitem__       a.__le__            a.__str__
a.__delslice__      a.__len__           a.append
a.__doc__           a.__lt__            a.count
a.__eq__            a.__mul__           a.extend
a.__ge__            a.__ne__            a.index
a.__getattribute__  a.__new__           a.insert
a.__getitem__       a.__reduce__        a.pop
a.__getslice__      a.__reduce_ex__     a.remove
a.__gt__            a.__repr__          a.reverse
a.__hash__          a.__reversed__      a.sort
\end{lstlisting}

La descripción detallada de todos los métodos para cada uno de los
tipos puede encontrarse en la referencia oficial del lenguaje
\cite{REF} que se distribuye conjuntamente con el tutorial mencionado
anteriormente.  Mientras seguir con atención el tutorial es casi
imprescindible para programar la referencia existe únicamente como
herramienta de consulta.

Quizás una de las cosas que más caracteriza las listas en Python es su
creación mediante los \emph{list comprehensions}

\begin{lstlisting}
>>> [(x, x**2) for x in vec]
[(2, 4), (4, 16), (6, 36)]
>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [x*y for x in vec1 for y in vec2]
[8, 6, -18, 16, 12, -36, 24, 18, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
\end{lstlisting}

\begin{small}
  \paragraph*{Ejercicio}
  Crear una lista que contenga las cadenas de texto\texttt{uno},
  \texttt{dos}, \texttt{tres} y \texttt{cuatro}.  Mover los elementos
  que contienen la letra \emph{o} a una lista nueva. Primero hacerlo
  con un bucle y luego mediante una copia y el comando \texttt{del}.
\end{small}

\subsection{La biblioteca estándar}

Una de las particularidades de Python como lenguaje es la gran
extensión temática de su biblioteca estándar.  Lejos de mantenerse
ajeno de las bibliotecas y aplicaciones muchos de los módulos de uso
común se han \emph{oficializado} hasta formar parte de la distribución
oficial.

Está perfectamente documentada en \cite{STB}. Dentro de la misma
encontramos módulos para:

\begin{itemize}
\item Manipulación textual
\item Envío de correos electrónicos
\item Proceso de contenido en XML, csv, XDR...
\item Criptografía
\item Interacción con el sistema operativo
\item Compresión de datos
\item Almacenamiento de variables
\item Enlazado con librerías externas.
\item Acceso a las funcionalidades POSIX
\item IPC y redes.
\item Protocolos de internet (XMLRPC, cookies, cgi, smtp, http, ftp...)
\item Multimedia
\item GUI
\item Internacionalización
\item Documentación
\item Tests
\item Debugging
\item Profiling
\end{itemize}

Es una lista considerable para ser una biblioteca estandar si se
compara con libc o la STL.  Esta lista no tiene en cuenta en ningún
caso todos los módulos no oficiales que pueden encontrarse en el
Python Package Index \url{http://pypi.python.org/pypi}.

\begin{small}
  \paragraph*{Ejercicio}
  A partir del módulo os ejecutar la orden \texttt{ls} para ver el
  contenido del directorio actual.
\end{small}

\begin{small}
  \paragraph*{Ejercicio}
  A partir del módulo sys conseguir que un programa escrito en Python
  devuelva una ayuda al pasarle el argumento \emph{-h}
\end{small}


% \section{Numpy}

% La consciencia minimalista del lenguaje obliga a que no haya ningún
% tipo dedicado a la manipulación de datos n-dimensionales. De todos los
% tipos disponibles las listas son 

% \section{Scipy}

% \section{SAGE}

% \section{Técnicas y herramientas para eliminar cuellos de botella}

% \section{Supercomputación con Python}

% \appendix

% \section{Python 3.x}

% \emph{Esta sección deberá eliminarse en cuando la siguiente versión de
% Python, la 3.x se haya consolidado}

% Python es en la actualidad un lenguaje en plena transición a una nueva
% versión.  El gran objetivo de Python 3.x, anteriormente conocido como
% Python 3000, es eliminar ciertos errores cometidos en los primeros
% estadios del desarrollo del lenguaje y que se han mantenido en él por
% la voluntad de no romper todo el código escrito. El objetivo
% secundario es conseguir ahondar en la propia filosofía de Python como
% lenguaje sencillo, consistente y corto.

% A partir de la llegada de Python 3.x el código que ejecute en Python
% 2.x debe escribirse teniendo en cuenta muy seriamente los avisos del
% intérprete en tiempo de ejecución.  En ellos se detallan problemas que
% pueden aparecer en un futuro proceso de migración.

% Es también una demostración de valentía.  Python es ya un lenguaje
% maduro y este cambio puede romper infinidad de código que hoy funciona
% sin ningún problema.  Lejos de ser algo que concierne sólo a unos
% pocos desarrolladores sitios como Google, YouTube, NASA y miles de
% empresas, sitios o proyectos de software tendrán que dedicar algo de
% tiempo ---esperemos que no mucho--- al cambio de versión.

% \section{Cómo instalar Python}
% \label{sec:instalar}

% CPython es el nombre que recibe habitualmente la implementación
% estándar en C y la más difundida. Ha sido portada a una veintena de
% sistemas operativos desde Windows a Symbian.

% Python se encuentra ya instalado en todas las distribuciones populares
% de GNU/Linux porque es un lenguaje de uso común para tareas de
% configuración y administración del sistema.  Para instalar módulos
% adicionales es recomendable utilizar el sistema de paquetes del propio
% sistema operativo para que las actualizaciones se produzcan
% automáticamente.

% En la página web \url{http://python.org/}


\begin{thebibliography}{99}

\bibitem[TUT]{TUT}
  Python Tutorial; Guido van Rossum, Python Software Foundation;
  \newblock \url{http://docs.python.org/tut/tut.html}

\bibitem[REF]{REF}
  Python Reference Manual; Guido van Rossum, Python Software Foundation;
  \newblock \url{http://docs.python.org/ref/ref.html}

\bibitem[STB]{STB}
  Python Library Reference; Guido van Rossum, Python Software Foundation;
  \newblock \url{http://docs.python.org/lib/lib.html}

\bibitem[OCT]{OCT}
  Introducción Informal a Matlab y Octave; Guillem Borrell i Nogueras;
  \newblock \url{http://iimyo.forja.rediris.es}. ISBN: 978-8-4691-3626-3

\end{thebibliography}

\end{document}
