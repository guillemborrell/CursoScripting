\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}

% \usepackage{pgfpages}
% \pgfpagesuselayout{2 on 1}[a4paper,border shrink=5mm]

\renewcommand\shorthandsspanish{}
\noextrasspanish

\title{Python como Entorno Científico de Desarrollo}
\author{
Guillem Borrell i Nogueras\\
\texttt{guillemborrell@gmail.com}
}

\begin{document}

\lstset{language=Python,
  backgroundcolor=\color{black!20},
  numbers=left,
  extendedchars=true,
  inputencoding=utf8,
  showspaces=false}

\begin{frame}
\begin{center}
 \includegraphics[width=9cm]{files/python-logo-generic.pdf}\\
 % python-logo-generic.pdf: 389x115 pixel, 72dpi, 13.72x4.06 cm, bb=0 0 389 115
\begin{large}
\textbf{Python como Entorno de Desarrollo Científico}
\end{large}\\

Guillem Borrell i Nogueras\\

Curso i-MATH, Julio-Septiembre de 2008
\end{center}

\end{frame}


\begin{frame}
  \frametitle{Yo.}
  \begin{itemize}
  \item Guillem Borrell i Nogueras.
  \item Ingeniero Aeronáutico (aunque no me gustan los aviones).
  \item Becario del Grupo de Investigación de Mecánica de Fluidos
    Computacional de la Universidad Politécnica de Madrid.
  \item Consultor Senior de Englobe Technologies.
  \item \textit{I Have Become Comfortably Numb},
    \url{http://torroja.dmt.upm.es/guillem/blog/}
  \item \textit{Introducción Informal a Matlab y Octave},
    \url{http://iimyo.forja.rediris.es/}
  \end{itemize}
\end{frame}

\begin{frame}
 \frametitle{Dos mundos distintos}
\begin{center}
 \begin{tabular}[h]{cc}
   \includegraphics[width=5cm]{files/nigerian-machine.jpg} &
   \includegraphics[width=5cm]{files/marenostrum.jpg}\\
   Pequeño & Grande
 \end{tabular}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Scripts}
\begin{itemize}
\item 1 Procesador
\item 1 Thread
\item ejecución $\sim$ segundos
\item GUI
\item Normalmente < $10^3$ lineas de código.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{HPC}
\begin{itemize}
\item > 8 Procesadores
\item > 8 Procesos o Threads
\item ejecución $\sim$ horas
\item no GUI
\item Quizás > $10^3$ líneas de código.
\end{itemize}
\end{frame}

\begin{frame}
 \frametitle{Dos mundos distintos}
\begin{center}
 \begin{tabular}[h]{cc}
   \includegraphics[width=5cm]{files/huevo.jpg} &
   \includegraphics[width=5cm]{files/castana.jpg}\\
   Huevo & Castaña
 \end{tabular}
\end{center}
\end{frame}


\begin{frame}
 \frametitle{¿Por qué se llama Python?}
 Python debe su nombre a...
\end{frame}

\begin{frame}
 \begin{center}
 \includegraphics[width=9cm]{files/python.jpg}\\
 % python.jpg: 760x544 pixel, 72dpi, 26.81x19.19 cm, bb=0 0 760 544
Monty Python
\end{center}

\end{frame}

\begin{frame}
 \frametitle{¿Quién usa Python?}

\begin{center}
 \includegraphics[width=3cm]{files/google.jpg}
 \includegraphics[width=3cm]{files/Industrial_Light_and_Magic.jpg}
 \includegraphics[width=3cm]{files/NASA_Logo.jpg}\\
 \includegraphics[width=3cm]{files/honeywell_logo.jpg}
\end{center}
\end{frame}

\begin{frame}
 \frametitle{¿Para qué sirve Python?}
 \begin{center}
 Prácticamente para cualquier cosa que se nos pueda ocurrir
 \end{center}

\end{frame}

\begin{frame}
 \frametitle{Desde páginas web...}
\begin{center}
 \includegraphics[width=9cm]{files/snapshot1.jpg}\\
 % snapshot1.jpg: 925x659 pixel, 762dpi, 3.08x2.20 cm, bb=0 0 87 62
Plone, Zope
\end{center}

\end{frame}

\begin{frame}
 \frametitle{...A utilidades para bioinformática}
\begin{center}
 \includegraphics[width=8cm]{files/pymol.jpg}\\
 % pymol.jpg: 720x540 pixel, 72dpi, 25.40x19.05 cm, bb=0 0 720 540
Pymol
\end{center}

\end{frame}

\begin{frame}
 \frametitle{Principales características de Python}

\begin{itemize}
 \item Software Libre (Licencia estilo BSD)
 \item Interpretado
 \item Interactivo
 \item Multiparadigma
 \begin{itemize}
  \item Procedimental
  \item Modular
  \item Orientado a Objetos
 \end{itemize}
 \item Multiplataforma
 \item Especificación especialmente corta (IronPython, Jython, PyPy,
   tinypy ...)
 \item \emph{Incluye las pilas}
 \item ...
\end{itemize}

\end{frame}

\begin{frame}
 \frametitle{¿Por qué Python se está volviendo tan popular}
\begin{itemize}
 \item Fácil de aprender
 \item Fácil de ampliar
 \item Consistente por diseño
 \item Impone un buen estilo de programación
 \item Soporta todas las prácticas propuestas por XP, Agile.
\end{itemize}
\begin{center}
 Porque es divertido
\end{center}
\end{frame}

\begin{frame}
 \frametitle{¿Por qué Python y no otro lenguaje?}
\begin{itemize}
 \item Fácilmente extensible.
 \begin{itemize}
 \item CPython, escrito en ANSI C.
\end{itemize}
 \item Dinámico.
 \item Software Libre.
 \item Excelente documentación.
\end{itemize}
\end{frame}


\begin{frame}
\begin{center}
\begin{LARGE}
¿Qué pinta tiene código escrito en Python?
\end{LARGE} 
\end{center}
\end{frame}

\defverbatim[colored]\testcode{
\begin{lstlisting}
guillem@aiguaviva ~ $ python
Python 2.4.4 (#1, Sep 25 2007, 21:44:53)
[GCC 4.1.2 (Gentoo 4.1.2)] on linux2
Type "help", "copyright", "credits" or "license" ...
>>> import cmath
>>> i=cmath.sqrt(-1) #Los namespaces son objetos
>>> i.conjugate() #Los numeros son objetos
-1j
>>> i.imag
1.0
>>> i.real
0.0
>>> i+=3 
>>> i
(3+1j)
\end{lstlisting}
}

\begin{frame}
\frametitle{Todo es un objeto}
\testcode
\end{frame}

\defverbatim[colored]\testcode{
\begin{lstlisting}
>>> def sumauno(numero):
...     return numero+1
...
>>> sumauno(i)
(4+1j)
\end{lstlisting}
}
\begin{frame}
\frametitle{Definir funciones es muy fácil}
\testcode
\begin{itemize}
 \item No hay llaves ni ends, los niveles se definen por el sangrado.
\end{itemize}
\end{frame}


\defverbatim[colored]\testcode{
\begin{lstlisting}
>>> def docfunc():
...     """Esta es una funcion documentada, a diferencia
...     de Matlab la documentacion de las funciones de
...     Python es extraible y formateable"""
...     pass
...
>>> help(docfunc)
Help on function docfunc in module __main__:

docfunc()
    Esta es una funcion documentada, a diferencia de
    Matlab la documentacion de las funciones de Python
    es extraible y formateable
\end{lstlisting}}

\begin{frame}
\frametitle{Documentaci\'on a la Matlab}
\testcode
\end{frame}


%%%%%%%%%%%%%%%% Scripting %%%%%%%%%%%%%%%%%%

\begin{frame}
 \frametitle{python para huevos (pequeños)}
  \begin{center}
 \begin{tabular}[h]{ccc}
   \includegraphics[width=5cm]{files/huevo.jpg} & &
   \includegraphics[width=5cm]{files/nigerian-machine.jpg}\\
   Huevo & = &Pequeño
 \end{tabular}
\end{center}
\end{frame}

\begin{frame}
  \frametitle{Somos insaciables.}
Queremos un lenguaje de programación...
  \begin{itemize}
  \item Que sea completo según Turing.
  \item Que lo haga \textbf{todo}
  \item Que lo haga \textbf{bien}
  \item Que no me cueste
  \item Que no tenga que mirar el manual
  \item Que ejecute en cualquier sitio.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{¿Java?}
  \begin{itemize}
  \item ¿Matemáticas con Java?
  \item ¿Ganancia respecto a C++?
  \item ¿Existe una comunidad de usuarios?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Matlab}
  \begin{itemize}
  \item Uno de los lenguajes de programación más patéticos que he
    visto
  \item ¿Por qué pagar $\sim$ 10000 Euros por algo que no lo vale?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Mathematica, Maple...}
  \begin{center}
    DSL. He dicho lenguaje de programación.
  \end{center}
\end{frame}



%%%%%%%%%%%%%%%% HPC %%%%%%%%%%%%%%%%%%


\begin{frame}
 \frametitle{python para castañas (grandes)}
  \begin{center}
 \begin{tabular}[h]{ccc}
   \includegraphics[width=5cm]{files/castana.jpg}& &
   \includegraphics[width=5cm]{files/marenostrum.jpg}\\
   Castaña & = & Grande
 \end{tabular}
\end{center}
\end{frame}

\begin{frame}
  \frametitle{Same old story}
  \begin{center}
    \begin{Huge}
      \textbf{HPC = Fortran, C}
    \end{Huge}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Ganaremos}
  \begin{itemize}
  \item Velocidad
  \item Gestión directa de la memoria
  \item ¿Algo más?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Perderemos:}
  \begin{itemize}
  \item Interactividad
  \item Garbage collection
  \item Versatilidad
  \item Sencillez
  \item Librerías
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{LARGE}
    ¿Podemos quedarnos con lo mejor de los dos mundos?      
    \end{LARGE}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{¿Por qué los lenguajes interpretados son lentos?}
  Porque son dinámicos.
  \begin{center}
    \begin{tikzpicture}      
      \node (lexer) at (0,0) [draw=black, thick, fill=black!10]
      {Lexer};

      \node (parser) at (2,0) [draw=black, thick, fill=black!10]
      {Parser};

      \node (encoder) at (4,0) [draw=black, thick, fill=black!10]
      {Encoder};

      \node (vm) at (7,0) [draw=black, very thick, fill=black!10]
      {VM};

      \node (codigo) at (0,1) [draw=blue,rounded
      corners,thick,fill=blue!20] {Codigo};

      \node (tokens) at (1,-1) [draw=blue,rounded
      corners,thick,fill=blue!20]
      {Tokens};

      \node (tokensp) at (3,1) [draw=blue,rounded
      corners,thick,fill=blue!20]
      {Tree};

      \node (bytecode) at (5.5,-1) [draw=blue,rounded
      corners,thick,fill=blue!20]
      {Bytecode};

      \node (assembler) at (8.5,1) [draw=blue,rounded
      corners,thick,fill=blue!20]
      {Assembler};
      
      \draw[->] (codigo.south) -- (lexer.north);

      \draw[->] (lexer.south) |- (tokens.west);

      \draw[->] (tokens.east) -| (parser.south);

      \draw[->] (parser.north) |- (tokensp.west);

      \draw[->] (tokensp.east) -| (encoder.north);

      \draw[->] (encoder.south) |- (bytecode.west);

      \draw[->] (bytecode.east) -| (vm.south);
      
      \draw[->] (vm.north) |- (assembler.west);
    \end{tikzpicture}
  \end{center}

\end{frame}

\begin{frame}
  \frametitle{Lenguajes dinámicos}
  \begin{itemize}
  \item El tipo de las variables sólo se sabe en tiempo de ejecución.
  \item El bytecode mueve un \textit{objectspace} o \textit{stack}
  \item El ensamblador de la máquina virtual hace lo que le dice el
    bytecode.
  \item La máquina virtual es incapaz de generar ensamblador
    optimizado.
  \item Dos planteamientos para lenguajes dinámicos
    \begin{itemize}
    \item Duck typing
    \item Type inference
    \end{itemize}
  \end{itemize}
\end{frame}

\defverbatim[colored]\testcode{
\begin{lstlisting}
 >>> class pato:
...     cantidad = 1
...     def haz_cua(self):
...           print "cua!"
...
...     def reproducete(self):
...           cantidad += 1
...
>>> estoesunpato=pato() #instancia de pato
>>> estoesunpato.cantidad
1
>>> estoesunpato.haz_cua()
cua!
\end{lstlisting} 
}

\begin{frame}
\frametitle{Duck typing}
\testcode
\end{frame}

\defverbatim[colored]\testcode{
\begin{lstlisting}
>>> estoesunpato=pato() #instancia de pato
>>> cuaqueador(estoesunpato)
cua!
>>> class guillem:
...     def haz_cua(self):
...             print "cua!"
...
>>> falsopato=guillem() #ese soy yo
>>> cuaqueador(falsopato)
cua!
>>> isinstance(falsopato,pato)
False
\end{lstlisting}
}
\begin{frame}
 \frametitle{Duck typing}
Si algo anda como un pato y hace cua como un pato para mi va a ser un pato.

Para la función cuaqueador yo soy tan pato como un pato.
\end{frame}

\begin{frame}
  \frametitle{Type inference}
  \begin{itemize}
  \item Intenta descubrir los tipos de cada variable en tiempo de
    compilación.
  \item El lenguaje es dinámico en apariencia pero estático en
    memoria.
  \item Menos dinámico que el Duck typing.
    \begin{itemize}
    \item Errores en tiempo de compilación
    \item Casting automático.
    \end{itemize}
  \item Mejor rendimiento.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JIT}
  Just In Time
  \begin{itemize}
  \item Método para optimizar el bytecode.
    \begin{itemize}
    \item Analiza el bytecode.
    \item Hace type inference.
    \item Genera ensamblador optimizado para la arquitectura.
    \end{itemize}
  \item Matlab lo utiliza para los bucles.
  \item Octave va detrás de ello.
  \item Python no tiene... PyPy sí, aunque muy verde.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Global Interpreter Lock}
  Otro problema de python (y otros).
  \begin{itemize}
  \item La máquina virtual sólo puede ejecutar un thread.
  \item No tendremos multithreading por muy trivial que quede en el
    bytecode.
  \item Si queremos threads tendremos que pedirlos
  \item Estensiones con propia gestión de threads.
  \item Con un poco de suerte se arreglará, de otra forma python
    morirá.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{La solución}
  \begin{center}
    \begin{Huge}
      Optimización Selectiva
    \end{Huge}
  \end{center}
  \vspace{1cm}
  \begin{flushright}
    \textit{We should forget about small efficiencies, say about 97\%
      of the time: premature optimization is the root of all evil. Yet
      we should not pass up our opportunities in that critical 3\%}. Knuth
  \end{flushright}
\end{frame}

\begin{frame}
  \frametitle{La regla del 80-20}
  \begin{itemize}
  \item El 80\% del código se escribe en el 20\% de tiempo.
  \item El 80\% del código es para tareas triviales, sólo el 20\%
    calcula algo de verdad.
  \item Del anterior, sólo el 20\% es realmente intensivo.
  \item Ergo sólo tendremos que optimizar un 5\% del código.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Estrategia a seguir}
  \begin{flushright}
    \textit{Bottlenecks occur in surprising places, so don't try to
      second guess and put in a speed hack until yo have proven that's
      where the bottleneck is}. Rob Pike
  \end{flushright}
  \vspace{1cm}
  \begin{itemize}
  \item Hacer un buen profiling del código.
  \item Descubrir los cuellos de botella.
  \item \textbf{Eliminar el componente dinámico del lenguaje donde sea
    estrictamente necesario.}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{Huge}
      Siempre que no tengamos que paralelizar.
    \end{Huge}
  \end{center}
\end{frame}


\begin{frame}
  \frametitle{Para ello...}
  \begin{itemize}
  \item Escribir extensiones a la Máquina virtual con C (Python.h)
  \item Escribir módulos en Fortran (f2py)
  \item Enlazar al intérprete bibliotecas en C o Fortran (ctypes,
    swig)
  \item Utilizar un lenguaje de extensión (pyrex, cython)
  \item Crear nuestra propia versión de python (PyPy)
  \item[$\rightarrow$] Utilizar un intérprete preparado para el cálculo paralelo
    (ipython1)
  \end{itemize}
\end{frame}

\begin{frame}
\begin{center}
 \includegraphics[width=6cm]{files/catbert.png}\\
\end{center}
\end{frame}

\beamertemplatesolidbackgroundcolor{red}

\begin{frame}
  \begin{center}
    \begin{Huge}
      \color{white}{\textbf{¿Con cuál me quedo?}}
    \end{Huge}
  \end{center}
\end{frame}

\beamertemplatesolidbackgroundcolor{white}

\end{document}
